540749012@qq.com
40719208

1.细看了over-allocated分配空间大小的增长规律，4 4 8 9 10 11 12...不知道这样设计的缘由。
2."当tuple的大小不超过20时，Python会把它缓存在内部的一个free list中。"这句话突然让我想起了小整数池。
小整数池的概念：Python提前建立好范围在[-5, 256]的整数对象，且不会被垃圾回收。无论这个整数处于LEGB中的哪个位置，所有位于这个范围内的整数使用的都是同一个对象。
主要目的是为了避免频繁申请和销毁小整数的内存空间，提高程序的运行效率。
3.说一下我所理解的新哈希表的设计思想：
indice下标，entry入口。用下标去寻找对应元素。
维护一个数据量较小的结构，去访问一个数据量较大的结构。
同理，也被运用于函数：
函数的本质是在堆Heap中放置的对象；
函数名的本质是放在栈Stack中的地址，指向堆中放置的对象。

以上，思维比较发散，说得不对还望指出。


1.比较操作符'is'的速度效率，通常要优于'=='。因为'is'操作符不能被重载，这样，Python 就不需要去寻找，程序中是否有其他地方重载了比较操作符，并去调用。执行比较操作符'is'，就仅仅是比较两个变量的 ID 而已。
2.list的切片和list()构造函数都是常见的浅拷贝；
另外，import copy调用copy.copy(xxx)同样也能做到浅拷贝。
tuple是个例外，浅拷贝不会重新分配内存，结果会指向同一份引用，id比较返回True。
这是因为上节课中所说的，Python对tuple的缓存优化导致的现象吗？
3.文中说到，“深度拷贝...将原对象中的元素，以递归的方式，通过...”。
关于deepcopy源码，我是这样理解的：
因为Python的递归深度是有限的，超出递归深度会引发RuntimeError异常，为了防止这种不必要的拷贝，做了查询字典检查已存对象的判断。

思考题：
>>> import copy
>>> x = [1]
>>> x.append(x)
>>> x
[1, [...]]
>>> y=copy.deepcopy(x)
>>> x==y
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
RecursionError: maximum recursion depth exceeded in comparison
















